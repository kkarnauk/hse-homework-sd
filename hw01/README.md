### HW01 CLI

# Архитектура

Наше приложение состоит из трех основных компонент: **Parser**, **Controller** и **Command Executor**. **Parser** отвечает за обработку пришедшей строки, на выход выдает некое представление `Expression`, **CommandExecutor** отвечает за запуск соответсвующих комманд, **Controller** отвечает за взаимодействие между **Parser** и **Command Executor**. Разберем каждую из компонент подробнее.

## Parser
Состоит из `Lexer`, `Parser`, `Token` и `InputPreprocessor`. 
* `InputPreprocessor`. Содержит единственный метод `substitute()`, который осуществляет подстановку переменных окружения, строя новую строку с уже подставленными значениями при помощи следующего алгоритма:
  * Назовем кавычки внешними, если они не содержатся внутри других кавычек. Идем по каждому символу строки. Если встретили знак `$` и при этом мы **не** находимся внутри внешних одинарных кавычек, то далее идем по каждому следующему символу до тех пор, пока не встретим пробел или другую кавычку любого типа и вместо полученного имени переменной достаем из окружения соответствующее значение переменной и в результирующую строку добавляем именно значение переменной.  
* `Lexer`. Представляет интерфейс обычного лексера с единственным методом `getNextToken()`. Конкретно в нашей реализации имеет имплементацию `LexerImpl`, которая разбивает текст на токены из `Token`.
* `Token`. Enum, который хранит в себе следующие токены:
  * _str_: строка без пробелов
  * _str_in1_: строка с пробелами, которая обернута в двойные кавычки
  * _str_in2_: строка с пробелами, которая обернута в одинарные кавычки
  * _assign_: =
  * _pipe_: |
  * _space_: один или несколько пробелов
  
  При получении значений токенов _str_in1_ и _str_in2_ кавычки по краям удаляются. 
* Грамматика: 
  ```
  Expression := (Command pipe Expr)* Command
  Command := (String space Args?) | Assignment
  Assignment := str space? assign space? String
  Args := (String space)* String
  String := str | str_in1 | str_in2
  ```
  Некоторым терминалам соответсвуют структуры, которые строятся во время парсинга:
  * `Command`: содержит имя команды(String) и список аргументов(List<String>). Для `AssigmentCommand` аргументами будут имя создаваемой переменной и её значение.
  * `Expression`: список `Command`. В случае одной команды состоит всего из одного аргумента, в случае пайплайна -- из нескольких. 
* `Parser`. Интерфейс парсера. Стандартная имплементация(`ParserImpl`) принимает в конструкторе строку, которая в дальнешем парсится в методе `parse()`. `Parser` использует `Lexer`, постепенно получая из него новые токены, которые обрабатываются при помощи соответсвующей грамматики. Попутно строится объект `Expression`, который возвращается в результате метода `parse()`.

## Controller
Представлен классами Main и Environment.

  * `Main`. В этом классе исполняется главный цикл нашей программы: 
    * В цикле считываем пользовательский ввод как строку. 
    * Выполняем обработку входной строки, выполняя все подстановки с помощью метода substitute у объекта класса InputPreprocessor, на выход получаем новую строку.
    * С помощью вызова метода parse у объекта класса Parser мы разбиваем строку на Token-ы с помощью лексера и парсим строку во внутреннее представление Expression
    * Далее вызываем Executor::execute и запускаем вычисление в Expression. На выходе получим ExecutionResult, сигнализирующий о том, закончилось вычисление успехом, ошибкой или прекратилось из-за вызова команды exit.
    * В конце мы обрабатываем результат вычисления, передав его в функцию `CheckResult()`, и можем вывести либо сообщение об ошибке, либо результат выполнения переданного выражения в зависимости от результата.

  * `Environment`. Singleton, являющийся обёрткой вокруг отображения из имени переменной в её значение для операции присвоения.
    * Отображения хранятся в `HashMap<String, String>`
    * Имеется флаг `isShutdowned` типа `Boolean`, который становится `true` в момент исполнения команды exit. После этого момента все дальнейшие вычисления производиться не будут.
    * `Environment::put` модифицирует окружение с помощью пары <имя переменной, значение переменной>

На данный момент не предусмотрена смена Environment-a при перемещении между директориями.
  
## Command Executor

  * `CommandStorage`. Хранилице наших команд, которые предстваляет из себя класс с полем storage: HashMap<String, Abstract Command> и методом getCommand(String): Abstract Command, который обращается к storage. Ключи - названия всех команд, значения - соответсвующие им классы
  * `IOEnvironment`. Класс с двумя полями:
    * _inputStream_: аргументы для текущей команды
    * _outputStream_: результат и логи предыдущей команды
  * `AbstractCommand`. Каждая команда в CLI -- это отдельный класс, который наследуется от него. Чтобы добавить новую команду необходимо просто отнаследоваться от AbstractCommand и реализовать метод execute(IOEnvironment): Result, который принимает потоки для чтения и записи, а сам метод внутри выполняет команду. 
    * `EchoCommand`: читает из inputStream и сразу же пишет в outputStream
    * `CatCommand`: последовательно открывает файлы из inputStream и записывает их содержимое(также последовательно) в outputStream
    * `PwdCommand`: игнорирует inputStream, записывает текущую директорию в outputStream 
    * `WcCommand`: пытается найти файл из inputStream, если не находит, то создаёт временный файл, записывает в outputStream количества строк, слов и байт полученного файла
    * `ExitCommand`: игнорирует inputStream, устанавливает isShutdowned в Environment -- в true, очичает outputStream
    * `AssignmentCommand`: вытаскивает из inputStream название переменной и её значение, в добавляет эту переменную в vars из Environment, очичает outputStream
    * `ExternalCommand`: вытаскиваем команду и аргументы из inputStream и исполняем внешнюю команду с помощью ProcessBuilder
  * `Executor`. Класс с методом `execute(Expr): Void` принимает `Expression`, то есть результат парсера. Он владеет `CommandStorage` и `IOEnvironment`. У каждой команды из `Expression` последовательно будет вызван метод `execute(IOEnvironment): Result` и передан _inputStream_ с аргументами для этой команды и _outputStream_ как поток для результата команды. В случае пайплайна после выполнения текущей инструкции нам нужно будет обновить аргументы для следующей команды, то есть записать в _inputStream_ результат команды, а именно то, что записалось в _outputStream_.
  * Многопоточность. Наше приложение многопоточность не поддерживает. Если какая-то команда будет выполняться в многопоточном режиме и как-то менять переменные окружения, то эти изменения никак не отразятся на результате, потому что подстановка переменных окружения происходит до запуска всех команд. Также если и делать поддержку многопоточности в пайплайне, то нужно аккуратно следить за потоками ввода-вывода в `IOEnvironment`. 

## Диаграмма Классов

<p align="center">
  <img src="ArchitectureCLI.jpeg" width="1000" title="screen_authorization">
</p>
